import 'dart:math' as math;

import '../entities/context_snapshot.dart';
import '../entities/psychometric_profile.dart';

/// Vulnerability-Opportunity Calculator: The "Thermostat" of JITAI
///
/// Computes two key scores:
/// - Vulnerability Score (V): Risk of habit failure (0.0-1.0)
/// - Opportunity Score (O): Receptivity to intervention (0.0-1.0)
///
/// The V-O state determines intervention strategy:
/// - High V, High O: Intervene now (user at risk but receptive)
/// - High V, Low O: Wait for better moment (user at risk but unreceptive)
/// - Low V, High O: Light touch or silence (user doing well)
/// - Low V, Low O: Silence (user fine, not receptive)
///
/// Phase 63: JITAI Foundation
class VulnerabilityOpportunityCalculator {
  /// Feature weights learned from population data (cold start defaults)
  /// These will be personalized via Thompson Sampling over time
  static const _defaultWeights = VOWeights();

  /// Calculate V-O state from context snapshot
  static VOState calculate({
    required ContextSnapshot context,
    required PsychometricProfile profile,
    VOWeights weights = _defaultWeights,
  }) {
    // === VULNERABILITY CALCULATION ===
    final vulnerability = _calculateVulnerability(context, profile, weights);

    // === OPPORTUNITY CALCULATION ===
    final opportunity = _calculateOpportunity(context, profile, weights);

    // === SHADOW TRIGGER (Predictive Failure) ===
    // If the model predicts high failure probability, spike vulnerability
    // to trigger Shadow intervention for rebels
    final predictiveFailure = _calculatePredictiveFailure(context, profile);
    final adjustedVulnerability = _applyPredictiveSpike(
      vulnerability,
      predictiveFailure,
      isRebel: _isRebelArchetype(profile),
    );

    return VOState(
      vulnerability: adjustedVulnerability.clamp(0.0, 1.0),
      opportunity: opportunity.clamp(0.0, 1.0),
      predictiveFailureProbability: predictiveFailure,
      dominantRiskFactors: _identifyDominantRisks(context, profile),
      dominantOpportunityFactors: _identifyDominantOpportunities(context),
      calculatedAt: DateTime.now(),
      userOverride: context.userVulnerabilityOverride,
    );
  }

  /// Calculate vulnerability score using profile.riskScore as base (O(1))
  /// with real-time context modifiers added on top
  static double _calculateVulnerability(
    ContextSnapshot context,
    PsychometricProfile profile,
    VOWeights weights,
  ) {
    // === BASE VULNERABILITY FROM PROFILE (O(1) lookup) ===
    // riskBitmask encodes persistent risk factors: weekend, evening, stress, etc.
    double baseVulnerability = profile.riskScore * 0.4; // 40% from profile

    // === REAL-TIME CONTEXT MODIFIERS (60%) ===
    double contextModifier = 0.0;

    // Time-based (apply if risk flag is active AND context matches)
    if (context.time.isWeekend && profile.isWeekendRisk) {
      contextModifier += 0.12;
    }
    if (context.time.isEvening && profile.isEveningRisk) {
      contextModifier += 0.08;
    }

    // Biometric (real-time sensor data)
    if (context.biometrics != null) {
      final bio = context.biometrics!;
      if (bio.isSleepDeprived) {
        contextModifier += 0.10 * (1 + bio.sleepZScore.abs() * 0.2);
      }
      if (bio.isStressed) {
        contextModifier += 0.08 * (1 + bio.hrvZScore.abs() * 0.2);
      }
    }

    // Digital distraction (real-time)
    if (context.digital != null && context.digital!.isHighDistraction) {
      contextModifier += 0.08;
    }

    // Historical momentum (recent behavior)
    if (context.history.daysSinceMiss <= 2) {
      final missRecency = 1.0 - (context.history.daysSinceMiss / 3.0);
      contextModifier += 0.12 * missRecency; // "Never miss twice" zone
    }

    // Resilience and habit strength
    if (context.history.resilienceScore < 0.4) {
      contextModifier += 0.06 * (1 - context.history.resilienceScore);
    }
    if (context.history.habitStrength < 0.3) {
      contextModifier += 0.06 * (1 - context.history.habitStrength);
    }

    // Weather (outdoor habits only)
    if (context.weather != null && !context.weather!.isOutdoorSuitable) {
      contextModifier += 0.08;
    }

    // === USER OVERRIDE (Thermostat) ===
    if (context.userVulnerabilityOverride != null) {
      final override = context.userVulnerabilityOverride!;
      // 70% user override, 30% calculated
      return override * 0.7 + (baseVulnerability + contextModifier) * 0.3;
    }

    return (baseVulnerability + contextModifier).clamp(0.0, 1.0);
  }

  /// Calculate opportunity score (receptivity to intervention)
  static double _calculateOpportunity(
    ContextSnapshot context,
    PsychometricProfile profile,
    VOWeights weights,
  ) {
    double score = 0.5; // Start at neutral

    // === CALENDAR OPPORTUNITY ===
    if (context.calendar != null) {
      final cal = context.calendar!;
      // In meeting = low opportunity
      if (cal.isInMeeting) {
        score -= 0.4;
      }
      // Good free window = high opportunity
      else if (cal.isGoodWindow) {
        score += 0.2;
        // Extra boost for large windows
        if (cal.freeWindowMinutes != null && cal.freeWindowMinutes! > 45) {
          score += 0.1;
        }
      }
    }

    // === TIME OPPORTUNITY ===
    // Peak energy window (from psychometrics)
    if (_isInPeakWindow(context.time.hour, profile.peakEnergyWindow)) {
      score += 0.15;
    }
    // Early morning (5-7am) often has high willpower
    if (context.time.hour >= 5 && context.time.hour < 8) {
      score += 0.1;
    }
    // Late night (after 10pm) typically low opportunity
    if (context.time.hour >= 22) {
      score -= 0.2;
    }

    // === LOCATION OPPORTUNITY ===
    if (context.location != null) {
      // At home = moderate opportunity
      if (context.location!.isAtHome) {
        score += 0.05;
      }
      // Near habit location = high opportunity
      if (context.location!.isNearHabitLocation) {
        score += 0.15;
      }
      // At gym (for exercise habits) = very high
      if (context.location!.isAtGym) {
        score += 0.2;
      }
    }

    // === INTERVENTION FATIGUE ===
    // Recent intervention = lower opportunity
    if (context.history.hoursSinceLastIntervention < 2) {
      score -= 0.2;
    }
    // Too many interventions today = fatigue
    if (context.history.isInterventionFatigued) {
      score -= 0.3;
    }

    // === MOMENTUM OPPORTUNITY ===
    // On a streak = higher baseline opportunity
    if (context.history.currentStreak > 7) {
      score += 0.1 * math.min(context.history.currentStreak / 30.0, 0.15);
    }

    // === BIOMETRIC OPPORTUNITY ===
    // Good sleep = higher opportunity
    if (context.biometrics != null && context.biometrics!.sleepZScore > 0.5) {
      score += 0.1;
    }
    // Good HRV (calm) = higher opportunity
    if (context.biometrics != null && context.biometrics!.hrvZScore > 0.5) {
      score += 0.1;
    }

    return score.clamp(0.0, 1.0);
  }

  /// Calculate predictive failure probability (for Shadow trigger)
  static double _calculatePredictiveFailure(
    ContextSnapshot context,
    PsychometricProfile profile,
  ) {
    // Simple heuristic-based prediction
    // This will be replaced with ML model prediction
    double failureProb = 0.3; // Base rate

    // Time-based risk
    if (context.time.isWeekend && profile.isWeekendRisk) {
      failureProb += 0.15;
    }
    if (context.time.isEvening && profile.isEveningRisk) {
      failureProb += 0.1;
    }

    // Biometric risk
    if (context.biometrics?.isSleepDeprived ?? false) {
      failureProb += 0.15;
    }
    if (context.biometrics?.isStressed ?? false) {
      failureProb += 0.1;
    }

    // Pattern risk
    if (context.activePatterns.contains('weekend_variance')) {
      failureProb += 0.1;
    }
    if (context.activePatterns.contains('energy_gap')) {
      failureProb += 0.1;
    }

    // Historical risk
    if (context.history.daysSinceMiss <= 1) {
      failureProb += 0.2; // "Never miss twice" danger zone
    }
    if (context.history.habitStrength < 0.2) {
      failureProb += 0.15;
    }

    return failureProb.clamp(0.0, 1.0);
  }

  /// Apply predictive spike for Shadow trigger
  static double _applyPredictiveSpike(
    double baseVulnerability,
    double predictiveFailure,
    {required bool isRebel}
  ) {
    // For rebels with high predicted failure, spike vulnerability
    // This triggers the Shadow intervention ("prove the algorithm wrong")
    if (isRebel && predictiveFailure > 0.6) {
      // Spike vulnerability to trigger Shadow intervention
      return math.max(baseVulnerability, 0.75);
    }

    // For non-rebels, blend prediction into vulnerability
    return baseVulnerability * 0.7 + predictiveFailure * 0.3;
  }

  /// Check if user has rebel archetype
  static bool _isRebelArchetype(PsychometricProfile profile) {
    final archetype = profile.failureArchetype?.toUpperCase() ?? '';
    return archetype.contains('REBEL') ||
           archetype.contains('DEFIANT') ||
           archetype.contains('CONTRARIAN');
  }

  /// Check if current hour is in peak energy window
  static bool _isInPeakWindow(int currentHour, String peakWindow) {
    // Parse window like "08:00 - 11:00"
    final match = RegExp(r'(\d{1,2}):?\d*\s*-\s*(\d{1,2})').firstMatch(peakWindow);
    if (match == null) return false;

    final start = int.tryParse(match.group(1)!) ?? 9;
    final end = int.tryParse(match.group(2)!) ?? 11;

    return currentHour >= start && currentHour < end;
  }

  /// Identify dominant risk factors for explainability
  static List<RiskFactor> _identifyDominantRisks(
    ContextSnapshot context,
    PsychometricProfile profile,
  ) {
    final risks = <RiskFactor>[];

    if (context.biometrics?.isSleepDeprived ?? false) {
      risks.add(RiskFactor(
        type: RiskType.sleepDeprivation,
        severity: 0.8,
        message: 'Low sleep last night',
      ));
    }

    if (context.biometrics?.isStressed ?? false) {
      risks.add(RiskFactor(
        type: RiskType.stress,
        severity: 0.7,
        message: 'Elevated stress (low HRV)',
      ));
    }

    if (context.time.isWeekend && profile.isWeekendRisk) {
      risks.add(RiskFactor(
        type: RiskType.weekendRisk,
        severity: 0.6,
        message: 'Weekend vulnerability pattern',
      ));
    }

    if (context.history.daysSinceMiss <= 1) {
      risks.add(RiskFactor(
        type: RiskType.recentMiss,
        severity: 0.9,
        message: 'Just missed yesterday',
      ));
    }

    if (context.weather != null && !context.weather!.isOutdoorSuitable) {
      risks.add(RiskFactor(
        type: RiskType.weather,
        severity: 0.5,
        message: 'Weather blocking outdoor activity',
      ));
    }

    // Sort by severity
    risks.sort((a, b) => b.severity.compareTo(a.severity));
    return risks.take(3).toList();
  }

  /// Identify dominant opportunity factors
  static List<OpportunityFactor> _identifyDominantOpportunities(
    ContextSnapshot context,
  ) {
    final opportunities = <OpportunityFactor>[];

    if (context.calendar?.isGoodWindow ?? false) {
      opportunities.add(OpportunityFactor(
        type: OpportunityType.freeWindow,
        strength: 0.8,
        message: 'Clear calendar window',
      ));
    }

    if (context.location?.isNearHabitLocation ?? false) {
      opportunities.add(OpportunityFactor(
        type: OpportunityType.location,
        strength: 0.7,
        message: 'Near habit location',
      ));
    }

    if (context.biometrics?.sleepZScore != null &&
        context.biometrics!.sleepZScore > 0.5) {
      opportunities.add(OpportunityFactor(
        type: OpportunityType.goodSleep,
        strength: 0.6,
        message: 'Well rested',
      ));
    }

    if (context.history.currentStreak > 7) {
      opportunities.add(OpportunityFactor(
        type: OpportunityType.momentum,
        strength: 0.5,
        message: '${context.history.currentStreak} day streak',
      ));
    }

    opportunities.sort((a, b) => b.strength.compareTo(a.strength));
    return opportunities.take(3).toList();
  }

  static const _riskPatterns = {
    'weekend_variance',
    'energy_gap',
    'wrong_time',
    'problematic_day',
    'environmental_block',
  };
}

// =============================================================================
// DATA CLASSES
// =============================================================================

/// The calculated V-O state
class VOState {
  final double vulnerability;
  final double opportunity;
  final double predictiveFailureProbability;
  final List<RiskFactor> dominantRiskFactors;
  final List<OpportunityFactor> dominantOpportunityFactors;
  final DateTime calculatedAt;
  final double? userOverride;

  VOState({
    required this.vulnerability,
    required this.opportunity,
    required this.predictiveFailureProbability,
    required this.dominantRiskFactors,
    required this.dominantOpportunityFactors,
    required this.calculatedAt,
    this.userOverride,
  });

  /// The quadrant this state falls into
  VOQuadrant get quadrant {
    final highV = vulnerability > 0.5;
    final highO = opportunity > 0.5;

    if (highV && highO) return VOQuadrant.interveneNow;
    if (highV && !highO) return VOQuadrant.waitForMoment;
    if (!highV && highO) return VOQuadrant.lightTouch;
    return VOQuadrant.silence;
  }

  /// Is this a critical state requiring immediate intervention?
  bool get isCritical => vulnerability > 0.8 && opportunity > 0.4;

  /// Is this a shadow trigger state (high predicted failure for rebels)?
  bool get isShadowTrigger => predictiveFailureProbability > 0.7;

  /// User has set manual override?
  bool get hasUserOverride => userOverride != null;

  /// Explainability: why this intervention was chosen
  String get explanation {
    final risks = dominantRiskFactors.map((r) => r.message).join(', ');
    final opps = dominantOpportunityFactors.map((o) => o.message).join(', ');

    if (risks.isEmpty && opps.isEmpty) {
      return 'Routine check-in';
    }

    final parts = <String>[];
    if (risks.isNotEmpty) parts.add('Risks: $risks');
    if (opps.isNotEmpty) parts.add('Opportunities: $opps');

    return parts.join(' | ');
  }

  Map<String, dynamic> toJson() => {
        'vulnerability': vulnerability,
        'opportunity': opportunity,
        'predictiveFailureProbability': predictiveFailureProbability,
        'quadrant': quadrant.name,
        'dominantRiskFactors': dominantRiskFactors.map((r) => r.toJson()).toList(),
        'dominantOpportunityFactors':
            dominantOpportunityFactors.map((o) => o.toJson()).toList(),
        'calculatedAt': calculatedAt.toIso8601String(),
        'userOverride': userOverride,
      };
}

/// V-O quadrant for intervention strategy
enum VOQuadrant {
  /// High V, High O: User at risk but receptive - intervene now
  interveneNow,

  /// High V, Low O: User at risk but unreceptive - wait for better moment
  waitForMoment,

  /// Low V, High O: User doing well, receptive - light touch or positive reinforcement
  lightTouch,

  /// Low V, Low O: User fine, not receptive - stay silent
  silence,
}

extension VOQuadrantExtension on VOQuadrant {
  String get description {
    switch (this) {
      case VOQuadrant.interveneNow:
        return 'Critical moment - intervene with support';
      case VOQuadrant.waitForMoment:
        return 'At risk but not receptive - wait for better timing';
      case VOQuadrant.lightTouch:
        return 'Doing well - light touch or positive reinforcement';
      case VOQuadrant.silence:
        return 'All good - stay silent';
    }
  }
}

/// Risk factor contributing to vulnerability
class RiskFactor {
  final RiskType type;
  final double severity; // 0.0-1.0
  final String message;

  RiskFactor({
    required this.type,
    required this.severity,
    required this.message,
  });

  Map<String, dynamic> toJson() => {
        'type': type.name,
        'severity': severity,
        'message': message,
      };
}

enum RiskType {
  sleepDeprivation,
  stress,
  weekendRisk,
  eveningRisk,
  recentMiss,
  lowResilience,
  weakHabit,
  weather,
  distraction,
  pattern,
}

/// Opportunity factor contributing to receptivity
class OpportunityFactor {
  final OpportunityType type;
  final double strength; // 0.0-1.0
  final String message;

  OpportunityFactor({
    required this.type,
    required this.strength,
    required this.message,
  });

  Map<String, dynamic> toJson() => {
        'type': type.name,
        'strength': strength,
        'message': message,
      };
}

enum OpportunityType {
  freeWindow,
  peakEnergy,
  location,
  goodSleep,
  calm,
  momentum,
}

/// Weight configuration for V-O calculation
class VOWeights {
  final double weekendRisk;
  final double eveningRisk;
  final double sleepDeprivation;
  final double stressHRV;
  final double highDistraction;
  final double recentMiss;
  final double lowResilience;
  final double weakHabitStrength;
  final double activeRiskPattern;
  final double badWeather;

  const VOWeights({
    this.weekendRisk = 0.15,
    this.eveningRisk = 0.12,
    this.sleepDeprivation = 0.20,
    this.stressHRV = 0.18,
    this.highDistraction = 0.10,
    this.recentMiss = 0.25,
    this.lowResilience = 0.15,
    this.weakHabitStrength = 0.12,
    this.activeRiskPattern = 0.08,
    this.badWeather = 0.10,
  });

  /// Create weights personalized for a user (from learned parameters)
  factory VOWeights.personalized(Map<String, double> learned) {
    return VOWeights(
      weekendRisk: learned['weekendRisk'] ?? 0.15,
      eveningRisk: learned['eveningRisk'] ?? 0.12,
      sleepDeprivation: learned['sleepDeprivation'] ?? 0.20,
      stressHRV: learned['stressHRV'] ?? 0.18,
      highDistraction: learned['highDistraction'] ?? 0.10,
      recentMiss: learned['recentMiss'] ?? 0.25,
      lowResilience: learned['lowResilience'] ?? 0.15,
      weakHabitStrength: learned['weakHabitStrength'] ?? 0.12,
      activeRiskPattern: learned['activeRiskPattern'] ?? 0.08,
      badWeather: learned['badWeather'] ?? 0.10,
    );
  }
}
