import 'package:flutter/foundation.dart';

import '../models/habit.dart';
import '../models/consistency_metrics.dart';
// Phase 14: Pattern Detection
import 'ai/ai_service_manager.dart';
import 'pattern_detection_service.dart'; // Phase 14
import 'smart_nudge/optimized_time_finder.dart'; // Phase 19
import 'smart_nudge/drift_analysis.dart' as drift; // Phase 19

/// Result of a weekly review generation
class WeeklyReviewResult {
  /// The AI-generated or fallback review text
  final String reviewText;

  /// Whether this was generated by AI (true) or local fallback (false)
  final bool isAiGenerated;

  /// The habit this review is for
  final Habit habit;

  /// The metrics used to generate this review
  final ConsistencyMetrics metrics;

  /// Summary stats for UI display
  final WeeklyStats stats;
  
  /// Phase 19: Time drift analysis (if significant drift detected)
  final drift.DriftAnalysis? driftAnalysis;
  
  /// Phase 19: Weekly pattern analysis (weekend vs weekday)
  final drift.WeeklyDriftPattern? weeklyPattern;

  WeeklyReviewResult({
    required this.reviewText,
    required this.isAiGenerated,
    required this.habit,
    required this.metrics,
    required this.stats,
    this.driftAnalysis,
    this.weeklyPattern,
  });
  
  /// Phase 19: Whether there's a time optimization suggestion
  bool get hasTimeOptimization => 
      driftAnalysis?.shouldSuggest == true || 
      weeklyPattern?.hasWeekendVariance == true;
}

/// Weekly statistics summary
class WeeklyStats {
  /// Days completed this week (0-7)
  final int daysCompleted;

  /// Day-by-day status for the week (oldest to newest)
  final List<DayStatus> weekHistory;

  /// Graceful Consistency score
  final double gracefulScore;

  /// Score change from previous week
  final double scoreChange;

  /// Total identity votes accumulated
  final int totalIdentityVotes;

  /// Quick recoveries this week
  final int recoveriesThisWeek;

  /// Current streak
  final int currentStreak;

  /// Whether a review is recommended (enough data)
  final bool reviewRecommended;

  WeeklyStats({
    required this.daysCompleted,
    required this.weekHistory,
    required this.gracefulScore,
    required this.scoreChange,
    required this.totalIdentityVotes,
    required this.recoveriesThisWeek,
    required this.currentStreak,
    required this.reviewRecommended,
  });
}

/// Simple day status for UI display
enum DayStatus { completed, missed, pending }

/// Service for generating AI-powered weekly habit reviews
/// 
/// Part of Phase 7: Analytics & Expansion
/// 
/// **Phase 14: Pattern Detection Integration**
/// Now includes pattern detection tags in AI prompts for personalized insights.
/// The LLM synthesizes local pattern data into actionable coaching.
/// 
/// This service:
/// 1. Aggregates habit data for the past 7 days
/// 2. Detects friction patterns using PatternDetectionService (Phase 14)
/// 3. Builds a context-aware prompt for Gemini with pattern insights
/// 4. Falls back to local heuristics if AI is unavailable
/// 5. Returns structured results for UI consumption
class WeeklyReviewService {
  final AIServiceManager _aiServiceManager;
  final PatternDetectionService _patternService = PatternDetectionService(); // Phase 14
  final OptimizedTimeFinder _driftDetector = OptimizedTimeFinder(); // Phase 19

  WeeklyReviewService(this._aiServiceManager);

  /// Generate a weekly review for a habit
  /// 
  /// Returns a [WeeklyReviewResult] containing either an AI-generated
  /// or local fallback review text.
  /// 
  /// Phase 19: Now includes time drift analysis and schedule optimization.
  Future<WeeklyReviewResult> generateReview(Habit habit) async {
    final metrics = habit.consistencyMetrics;
    final stats = _calculateWeeklyStats(habit, metrics);
    
    // Phase 19: Run drift analysis
    final driftAnalysis = _analyzeDrift(habit);
    final weeklyPattern = _analyzeWeeklyPattern(habit);
    
    // Build the prompt (now includes drift insights)
    final prompt = _buildPrompt(habit, metrics, stats, driftAnalysis, weeklyPattern);
    
    if (kDebugMode) {
      debugPrint('Weekly Review: Generating for "${habit.name}"');
      debugPrint('Weekly Review: ${stats.daysCompleted}/7 days completed');
      if (driftAnalysis?.shouldSuggest == true) {
        debugPrint('Weekly Review: Drift detected - suggest ${driftAnalysis?.suggestedTime?.formatAmPm()}');
      }
    }
    
    // Phase 24: Try AI generation with AIServiceManager
    final aiResponse = await _aiServiceManager.singleTurn(
      prompt: prompt,
      isPremiumUser: false, // TODO: Get from user profile
      isBreakHabit: habit.isBreakHabit,
    );
    
    if (aiResponse != null && aiResponse.isNotEmpty) {
      return WeeklyReviewResult(
        reviewText: aiResponse,
        isAiGenerated: true,
        habit: habit,
        metrics: metrics,
        stats: stats,
        driftAnalysis: driftAnalysis,
        weeklyPattern: weeklyPattern,
      );
    }
    
    // Fallback to local generation
    if (kDebugMode) {
      debugPrint('Weekly Review: Using local fallback');
    }
    
    return WeeklyReviewResult(
      reviewText: _generateLocalFallback(habit, metrics, stats),
      isAiGenerated: false,
      habit: habit,
      metrics: metrics,
      stats: stats,
      driftAnalysis: driftAnalysis,
      weeklyPattern: weeklyPattern,
    );
  }
  
  /// Phase 19: Analyze time drift for a habit
  drift.DriftAnalysis? _analyzeDrift(Habit habit) {
    if (habit.completionHistory.isEmpty) return null;
    
    try {
      return _driftDetector.analyze(
        completionHistory: habit.completionHistory,
        scheduledTime: habit.implementationTime,
      );
    } catch (e) {
      if (kDebugMode) {
        debugPrint('Weekly Review: Drift analysis failed: $e');
      }
      return null;
    }
  }
  
  /// Phase 19: Analyze weekly patterns (weekend variance, day-specific issues)
  drift.WeeklyDriftPattern? _analyzeWeeklyPattern(Habit habit) {
    if (habit.completionHistory.isEmpty) return null;
    
    try {
      return _driftDetector.analyzeWeeklyPattern(
        completionHistory: habit.completionHistory,
        scheduledTime: habit.implementationTime,
      );
    } catch (e) {
      if (kDebugMode) {
        debugPrint('Weekly Review: Weekly pattern analysis failed: $e');
      }
      return null;
    }
  }

  /// Check if a weekly review should be surfaced to the user
  /// 
  /// Returns true if:
  /// - At least 7 days have passed since habit creation
  /// - It's Sunday or Monday (ideal review days)
  /// - Or user hasn't seen a review in 7+ days
  bool shouldShowReviewPrompt(Habit habit, {DateTime? lastReviewDate}) {
    final now = DateTime.now();
    final daysSinceCreation = now.difference(habit.createdAt).inDays;
    
    // Need at least 7 days of data
    if (daysSinceCreation < 7) return false;
    
    // If we have a last review date, check if 7+ days have passed
    if (lastReviewDate != null) {
      final daysSinceLastReview = now.difference(lastReviewDate).inDays;
      if (daysSinceLastReview < 7) return false;
    }
    
    // Ideal to show on Sunday (0) or Monday (1)
    final isReviewDay = now.weekday == DateTime.sunday || now.weekday == DateTime.monday;
    
    return isReviewDay || lastReviewDate == null;
  }

  /// Calculate weekly statistics for UI display
  WeeklyStats _calculateWeeklyStats(Habit habit, ConsistencyMetrics metrics) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    
    // Get day-by-day status for the past 7 days
    final weekHistory = <DayStatus>[];
    int daysCompleted = 0;
    int recoveriesThisWeek = 0;
    
    for (int i = 6; i >= 0; i--) {
      final date = today.subtract(Duration(days: i));
      final wasCompleted = habit.completionHistory.any((d) =>
          d.year == date.year && d.month == date.month && d.day == date.day);
      
      if (wasCompleted) {
        weekHistory.add(DayStatus.completed);
        daysCompleted++;
        
        // Check if this was a recovery (previous day was missed)
        if (i < 6) {
          final previousDate = today.subtract(Duration(days: i + 1));
          final previousCompleted = habit.completionHistory.any((d) =>
              d.year == previousDate.year && 
              d.month == previousDate.month && 
              d.day == previousDate.day);
          if (!previousCompleted) {
            recoveriesThisWeek++;
          }
        }
      } else if (i == 0) {
        // Today - might still complete
        weekHistory.add(DayStatus.pending);
      } else {
        weekHistory.add(DayStatus.missed);
      }
    }
    
    // Determine if review is recommended
    final reviewRecommended = daysCompleted > 0 || metrics.recoveryCount > 0;
    
    return WeeklyStats(
      daysCompleted: daysCompleted,
      weekHistory: weekHistory,
      gracefulScore: metrics.gracefulScore,
      scoreChange: metrics.scoreChange,
      totalIdentityVotes: metrics.identityVotes,
      recoveriesThisWeek: recoveriesThisWeek,
      currentStreak: metrics.currentStreak,
      reviewRecommended: reviewRecommended,
    );
  }

  /// Build the AI prompt for weekly review generation
  /// Phase 14: Now includes pattern detection insights for personalized coaching
  /// Phase 19: Now includes time drift analysis for schedule optimization
  String _buildPrompt(
    Habit habit, 
    ConsistencyMetrics metrics, 
    WeeklyStats stats,
    drift.DriftAnalysis? driftAnalysis,
    drift.WeeklyDriftPattern? weeklyPattern,
  ) {
    // Build day-by-day history string
    final dayNames = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    final now = DateTime.now();
    final historyLines = <String>[];
    
    for (int i = 6; i >= 0; i--) {
      final date = now.subtract(Duration(days: i));
      final dayIndex = (date.weekday - 1) % 7; // Monday = 0
      final dayName = dayNames[dayIndex];
      final status = stats.weekHistory[6 - i];
      final emoji = status == DayStatus.completed ? '✅' : 
                    status == DayStatus.pending ? '⏳' : '❌';
      historyLines.add('$dayName: $emoji');
    }

    // Build context about the habit
    final habitContext = StringBuffer();
    habitContext.writeln('Habit: "${habit.name}"');
    habitContext.writeln('Identity goal: "${habit.identity}"');
    if (habit.tinyVersion.isNotEmpty) {
      habitContext.writeln('2-minute version: "${habit.tinyVersion}"');
    }
    if (habit.motivation != null && habit.motivation!.isNotEmpty) {
      habitContext.writeln('Motivation: "${habit.motivation}"');
    }
    if (habit.isBreakHabit && habit.replacesHabit != null) {
      habitContext.writeln('Breaking habit: "${habit.replacesHabit}"');
    }
    
    // Phase 14: Add pattern detection insights
    final patternSection = _buildPatternSection(habit);
    
    // Phase 19: Add drift analysis section
    final driftSection = _buildDriftSection(driftAnalysis, weeklyPattern);

    return '''
You are an empathetic habit coach using the "Graceful Consistency" philosophy from Atomic Habits.
Your role is to provide a brief, personalized weekly review that reinforces identity and celebrates recovery.

## User's Habit Context
${habitContext.toString()}

## Last 7 Days Progress
${historyLines.join('\n')}

## Weekly Statistics
- Days completed: ${stats.daysCompleted}/7
- Graceful Consistency Score: ${metrics.gracefulScore.toStringAsFixed(1)}/100
- Score change: ${metrics.scoreChange >= 0 ? '+' : ''}${metrics.scoreChange.toStringAsFixed(1)}
- Total identity votes: ${metrics.identityVotes}
- Quick recoveries this week: ${stats.recoveriesThisWeek}
- Current streak: ${metrics.currentStreak} days
$patternSection$driftSection
## Your Task
Write a 2-3 sentence personalized weekly review. Follow these rules:

1. **If perfect week (7/7):** Celebrate their commitment to their identity. Mention they're "becoming" their identity goal.

2. **If they recovered after a miss:** Lead with praise for recovery. Reference "Graceful Consistency" or "Never Miss Twice." Never shame the miss.

3. **If they struggled (<3 days):** Be compassionate. Suggest using their 2-minute version. Focus on "just showing up" next week.

4. **Always:** 
   - Use their habit name and identity in the response
   - Keep it under 50 words
   - End with encouragement or a small actionable tip
   - Use a warm but professional tone (not overly enthusiastic)

Write ONLY the review text, no headers or labels.
''';
  }

  /// Phase 19: Build drift analysis section for the AI prompt
  /// Helps the AI suggest schedule optimizations
  String _buildDriftSection(
    drift.DriftAnalysis? driftAnalysis, 
    drift.WeeklyDriftPattern? weeklyPattern,
  ) {
    final section = StringBuffer();
    
    if (driftAnalysis == null && weeklyPattern == null) {
      return '';
    }
    
    section.writeln('\n## Schedule Optimization Insights');
    
    // Add drift analysis
    if (driftAnalysis != null && driftAnalysis.sampleSize >= 7) {
      section.writeln('- Scheduled time: ${driftAnalysis.scheduledTime.formatAmPm()}');
      section.writeln('- Actual median completion: ${driftAnalysis.medianTime.formatAmPm()}');
      section.writeln('- Drift: ${driftAnalysis.driftMinutes.abs()} minutes ${driftAnalysis.driftMinutes > 0 ? 'later' : 'earlier'}');
      section.writeln('- Confidence: ${(driftAnalysis.confidence * 100).toInt()}%');
      
      if (driftAnalysis.shouldSuggest && driftAnalysis.suggestedTime != null) {
        section.writeln('- Suggested new time: ${driftAnalysis.suggestedTime!.formatAmPm()}');
        section.writeln('- NOTE: The user naturally does this habit at a different time. Consider mentioning this in your review.');
      }
    }
    
    // Add weekend variance insights
    if (weeklyPattern != null && weeklyPattern.hasWeekendVariance) {
      section.writeln('- Weekend variance detected: User does this habit at a different time on weekends');
      if (weeklyPattern.weekendSuggestedTime != null) {
        section.writeln('- Weekend suggested time: ${weeklyPattern.weekendSuggestedTime!.formatAmPm()}');
      }
    }
    
    // Add problematic days
    if (weeklyPattern != null && weeklyPattern.problematicDays.isNotEmpty) {
      final dayNames = ['', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      final problemDays = weeklyPattern.problematicDays
          .map((d) => dayNames[d])
          .join(', ');
      section.writeln('- Problematic days: $problemDays (consistent lateness on these days)');
    }
    
    section.writeln('');
    return section.toString();
  }
  
  /// Phase 14: Build pattern section for the AI prompt
  /// Synthesizes local pattern detection into coaching context
  String _buildPatternSection(Habit habit) {
    // Analyze patterns from miss history
    final patternSummary = _patternService.analyzeHabit(
      habit: habit,
      missHistory: habit.missHistory,
      completionHistory: habit.completionHistory,
      recoveryHistory: habit.recoveryHistory,
    );
    
    // If no significant patterns, return empty section
    if (patternSummary.patterns.isEmpty) {
      return '\n## Friction Patterns\nNo significant patterns detected yet.\n';
    }
    
    final section = StringBuffer();
    section.writeln('\n## Friction Patterns Detected');
    
    // Add pattern tags
    if (patternSummary.allTags.isNotEmpty) {
      section.writeln('Pattern tags: ${patternSummary.allTags.join(', ')}');
    }
    
    // Add top patterns with descriptions
    for (final pattern in patternSummary.patterns.take(2)) {
      section.writeln('- ${pattern.type.emoji} ${pattern.type.name}: ${pattern.description}');
      section.writeln('  Suggestion: ${pattern.suggestion}');
    }
    
    section.writeln('Pattern health score: ${patternSummary.healthScore.toInt()}/100');
    section.writeln('');
    
    return section.toString();
  }
  
  /// Generate a local fallback review when AI is unavailable
  String _generateLocalFallback(
    Habit habit, 
    ConsistencyMetrics metrics, 
    WeeklyStats stats,
  ) {
    final identity = habit.identity.isNotEmpty 
        ? habit.identity 
        : 'the person you want to become';
    final habitName = habit.name;
    
    // Perfect week
    if (stats.daysCompleted == 7) {
      return 'Outstanding week for "$habitName"! You showed up every single day, '
          'casting 7 identity votes for $identity. This is what consistency looks like. '
          'Keep building on this momentum!';
    }
    
    // Great week (5-6 days)
    if (stats.daysCompleted >= 5) {
      return 'Strong week with ${stats.daysCompleted}/7 days for "$habitName"! '
          'You\'re consistently showing up as $identity. '
          'A miss or two doesn\'t define you—your pattern of showing up does.';
    }
    
    // Recovery week (had recoveries)
    if (stats.recoveriesThisWeek > 0) {
      return 'Great job bouncing back this week on "$habitName"! '
          'Recovery is the most important skill in habit building. '
          'You proved you\'re committed to being $identity, even on hard days.';
    }
    
    // Decent week (3-4 days)
    if (stats.daysCompleted >= 3) {
      return 'You showed up ${stats.daysCompleted} times this week for "$habitName"—that\'s ${stats.daysCompleted} more identity votes! '
          'Next week, try using your 2-minute version on tough days. '
          'Showing up small still counts as $identity.';
    }
    
    // Struggling week (1-2 days)
    if (stats.daysCompleted > 0) {
      return 'You still showed up ${stats.daysCompleted} time${stats.daysCompleted > 1 ? 's' : ''} this week—that matters! '
          'Consider: what got in the way? '
          'Next week, focus on just 2 minutes of "$habitName". Small wins build momentum.';
    }
    
    // No completions
    return 'This week was tough for "$habitName", and that\'s okay. '
        'Every week is a fresh start. '
        'This week, try just showing up for 2 minutes—you\'re still $identity, one small step at a time.';
  }
}
